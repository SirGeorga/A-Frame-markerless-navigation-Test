<!DOCTYPE html>
<html>
  <head>
    <title>AR Navigation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://aframe.io/releases/1.3.0/aframe.min.js"></script>
    <script src="https://cdn.rawgit.com/donmccurdy/aframe-extras/v6.0.0/dist/aframe-extras.min.js"></script>
    <script src="https://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.rawgit.com/mrdoob/three.js/r110/examples/js/loaders/HDRCubeTextureLoader.js"></script>
    <script>
      AFRAME.registerComponent('ar-navigation', {
        init: function () {
          this.destinationPoints = [];
          this.navPath = null;
          this.navPoints = [];
          this.camera = null;
          this.envMap = null;
          this.obstacleMap = null;
          this.obstacleDetector = null;
          this.loader = new THREE.GLTFLoader();
          this.loader.setCrossOrigin('anonymous');
          this.initEnvironmentMap();
          this.initObstacleDetector();
          this.el.sceneEl.addEventListener('click', this.onScreenClick.bind(this));
        },
        initEnvironmentMap: function () {
          let loader = new THREE.HDRCubeTextureLoader();
          let hdrUrls = ['px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr'];
          loader.load(THREE.UnsignedByteType, hdrUrls, this.onEnvironmentMapLoaded.bind(this));
        },
        onEnvironmentMapLoaded: function (texture) {
          texture.encoding = THREE.RGBM16Encoding;
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.format = THREE.RGBAFormat;
          texture.generateMipmaps = false;
          this.envMap = texture;
        },
        initObstacleDetector: function () {
          this.obstacleMap = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
            format: THREE.RGBFormat,
            depthBuffer: true,
            stencilBuffer: false
          });
          this.obstacleDetector = new THREE.Object3D();
          this.el.sceneEl.object3D.add(this.obstacleDetector);
        },
        onScreenClick: function (event) {
          let camera = this.el.sceneEl.camera;
          let raycaster = new THREE.Raycaster();
          let mouse = new THREE.Vector2();
          mouse.x = (event.detail.clientX / window.innerWidth) * 2 - 1;
          mouse.y = - (event.detail.clientY / window.innerHeight) * 2 + 1;
          raycaster.setFromCamera(mouse, camera);
          let intersects = raycaster.intersectObjects(this.obstacleDetector.children, true);
          if (intersects.length > 0       ) {
        // Clicked on an obstacle, generate new path to avoid it
        let obstaclePos = intersects[0].point;
        this.generateNewPath(obstaclePos);
      } else {
        // Clicked on a clear path, add destination point
        let pos = new THREE.Vector3();
        pos.copy(camera.el.object3D.position);
        let rot = new THREE.Euler();
        rot.copy(camera.el.object3D.rotation);
        let dest = { position: pos, rotation: rot };
        this.addDestinationPoint(dest);
      }
    },
    addDestinationPoint: function (dest) {
      let point = this.createDestinationPoint(dest);
      this.destinationPoints.push(dest);
      this.navPoints.push(point);
      this.updateNavigationPath();
    },
    createDestinationPoint: function (dest) {
      let point = new THREE.Object3D();
      this.loader.load('destination.glb', function (gltf) {
        point.add(gltf.scene);
      });
      point.position.copy(dest.position);
      point.rotation.copy(dest.rotation);
      this.el.sceneEl.object3D.add(point);
      return point;
    },
    updateNavigationPath: function () {
      if (this.navPath != null) {
        this.el.sceneEl.object3D.remove(this.navPath);
      }
      if (this.destinationPoints.length > 1) {
        let points = [];
        for (let i = 0; i < this.destinationPoints.length; i++) {
          points.push(this.destinationPoints[i].position);
        }
        let path = this.createNavigationPath(points);
        this.navPath = path;
        this.el.sceneEl.object3D.add(path);
      }
    },
    createNavigationPath: function (points) {
      let curve = new THREE.CatmullRomCurve3(points);
      let geometry = new THREE.TubeBufferGeometry(curve, points.length * 20, 0.2, 8, false);
      let material = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        metalness: 0.5,
        roughness: 0.5,
        envMap: this.envMap,
        side: THREE.DoubleSide
      });
      let mesh = new THREE.Mesh(geometry, material);
      return mesh;
    },
    generateNewPath: function (obstaclePos) {
      let camera = this.el.sceneEl.camera;
      let obstacleVec = obstaclePos.clone().sub(camera.el.object3D.position);
      let obstacleDir = new THREE.Vector2(obstacleVec.x, obstacleVec.z).normalize();
      let forwardVec = new THREE.Vector3();
      camera.getWorldDirection(forwardVec);
      let forwardDir = new THREE.Vector2(forwardVec.x, forwardVec.z).normalize();
      let rightDir = forwardDir.clone().rotateAround(new THREE.Vector2(), -Math.PI / 2);
      let newDest = null;
      if (forwardDir.dot(obstacleDir) > 0) {
        // Obstacle is in front of camera, move to the right
        newDest = camera.el.object3D.position.clone().add(new THREE.Vector3(rightDir.x, 0, rightDir.y).multiplyScalar(5));
      } else {
        // Obstacle is on the right side of camera, move forward
        newDest = camera.el.object3D.position.clone().add(new THREE.Vector3(forwardDir.x, 0, forwardDir.y).multiplyScalar(5));
      }
      let dest = { position: newDest, rotation: camera.el.object3D.rotation };
      this.addDestinationPoint(dest);
    },
    tick: function (time, timeDelta) {
      if (this.camera == null)       {
        this.camera = this.el.sceneEl.camera;
      }
      if (this.destinationPoints.length == 0) {
        return;
      }
      let point = this.destinationPoints[0];
      let camera = this.camera;
      let dist = camera.el.object3D.position.distanceTo(point.position);
      if (dist < this.arrivalDistance) {
        this.destinationPoints.shift();
        this.el.sceneEl.object3D.remove(this.navPoints.shift());
        this.updateNavigationPath();
      } else {
        let forward = new THREE.Vector3();
        let right = new THREE.Vector3();
        let up = new THREE.Vector3(0, 1, 0);
        camera.getWorldDirection(forward);
        right.crossVectors(forward, up);
        let destinationVec = point.position.clone().sub(camera.el.object3D.position);
        let destinationDir = new THREE.Vector2(destinationVec.x, destinationVec.z).normalize();
        let forwardDir = new THREE.Vector2(forward.x, forward.z).normalize();
        let rightDir = forwardDir.clone().rotateAround(new THREE.Vector2(), -Math.PI / 2);
        let dotForward = destinationDir.dot(forwardDir);
        let dotRight = destinationDir.dot(rightDir);
        let rotation = new THREE.Euler();
        if (dotForward >= 0) {
          if (dotRight >= 0) {
            // Move forward-right
            rotation.set(0, -Math.PI / 4, 0);
          } else {
            // Move forward-left
            rotation.set(0, Math.PI / 4, 0);
          }
        } else {
          if (dotRight >= 0) {
            // Move back-right
            rotation.set(0, -3 * Math.PI / 4, 0);
          } else {
            // Move back-left
            rotation.set(0, 3 * Math.PI / 4, 0);
          }
        }
        let t = timeDelta / this.moveTime;
        camera.el.object3D.position.lerp(point.position, t);
        camera.el.object3D.rotation.copy(rotation);
      }
    }
  });


